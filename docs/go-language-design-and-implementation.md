### Go 语言设计与实现#### 参考资料* [《Go 语言设计与实现》](https://book.douban.com/subject/35635836/)#### 第二章 编译原理* Go的编译器在逻辑上可以被分成四个阶段：  1. 词法分析与语法分析：得到了每个文件对应的AST（抽象语法树）  1. 类型检查和AST转换：检查语法错误，代码优化，把make和new改成对应操作类型  1. 通用SSA生成：把AST生成SSA中间代码，对关键字再进行改写  1. 最后的机器代码生成：根据Arch和OS生成对应机器码，需要用到汇编器* 编译器一般分为前端和后端  * 前端的主要工作是将源代码翻译成编程语言无关的中间表示，即Go的前2个阶段  * 后端主要负责目标代码的优化和生成，即Go的后两个阶段#### 第三章 数据结构1. 数组：一块连续的内存1. 切片：24字节，uintptr、len、cap1. 哈希表：count(元素个数)、B(桶数量)、hash0(哈希种子)、buckets(桶数组)、oldbuckets(旧的桶数组)1. 字符串：16字节，uintptr、len。每一次写操作都是开辟新的空间。```// arr := []int{1,2,3} 的汇编，这里的SP是硬件SP	0x0014 00020 (hello.go:4)	MOVQ	$0, ""..autotmp_2+8(SP)  //arr[0]=0	0x001d 00029 (hello.go:4)	LEAQ	""..autotmp_2+16(SP), AX 	0x0022 00034 (hello.go:4)	MOVUPS	X15, (AX)              //arr[1]=0和arr[2]=0	0x0026 00038 (hello.go:4)	MOVQ	$1, ""..autotmp_2+8(SP)  //arr[0]=1	0x002f 00047 (hello.go:4)	MOVQ	$2, ""..autotmp_2+16(SP) //arr[1]=2	0x0038 00056 (hello.go:4)	MOVQ	$3, ""..autotmp_2+24(SP) //arr[2]=3	0x0041 00065 (hello.go:4)	LEAQ	""..autotmp_2+8(SP), AX  	0x0046 00070 (hello.go:4)	MOVQ	AX, "".arr+32(SP)        //sliceHeader.data=&arr  	0x004b 00075 (hello.go:4)	MOVQ	$3, "".arr+40(SP)        //sliceHeader.len=3	0x0054 00084 (hello.go:4)	MOVQ	$3, "".arr+48(SP)        //sliceHeader.cap=3```![Map](../images/go-map-struct.jpg)#### 第四章 语言特性* 函数调用：  * 通过栈传递参数和返回值，内存地址高~低依次是：ret1、ret0、arg1、arg0  * 调用函数都是值传递* 接口分为eface接口和iface接口* eface接口，不带任何方法* iface接口，例如Duck接口，Cat结构体实现了Duck的方法：  * 如果方法的接收者是结构体，即func (c Cat) Quack() {}    * var a1 Duck = Cat{} //正常编译运行    * var a2 Duck = &Cat{} //正常编译运行  * 如果方法的接收者是结构体指针，即func (c *Cat) Quack() {}    * var a1 Duck = Cat{} //编译报错    * var a2 Duck = &Cat{} //正常编译运行    * a1 := Cat{} //可正常调用a1.Quack()  * eface.tab包含有\*interfacetype和*_type    * *interfacetype表示抽象接口的信息    * \*_type表示具体类型的信息，它和*interfacetype._type不相等  * eface.tab._type指向的某个内存区域的起点，该内存区域包含type(具体类型)、uncommontype、\[mcount]method    * type(具体类型)：普通类型则是_type类型，特殊类型各自不同，如[struct、ptr等等](https://github.com/golang/go/blob/6c64b6db6802818dd9a4789cdd564f19b70b6b4c/src/runtime/type.go#L58)* 接口相关的文章  * [深度解密Go语言之关于 interface 的10个问题](https://www.cnblogs.com/qcrao-2018/p/10766091.html)  * [Go 和 interface 探究](https://xargin.com/go-and-interface/)  * [通过汇编和源码两大神器探究 —— Go语言接口](https://blog.csdn.net/qq_31930499/article/details/102532264)* 十种函数(方法)的调用形式  * 直接调用顶级函数：println()  * 直接调用一个值receiver的方法：(Cat{}).Quack()  * 直接调用一个指针receiver的方法：(&Cat{}).Quack()  * 间接调用一个interface的方法(包含有值方法的值)：var a Duck = Cat{} && a.Quack()  * 间接调用一个interface的方法(包含有值方法的指针)：var a Duck = &Cat{} && a.Quack()  * 间接调用一个interface的方法(包含有指针方法的指针)：var a Duck = &Cat{} && a.Quack()  * 间接调用方法值(值等于顶级方法)：a = println  * 间接调用方法值(值等于值方法)：a = (Cat{}).Quack  * 间接调用方法值(值等于指针方法)：a = (&Cat{}).Quack  * 间接调用方法值(值等于函数字面量)：a = func() {}* 反射的三大法则：  1. 变量->反射对象：func TypeOf(i interface{}) Type和func ValueOf(i interface{}) Value  1. 反射对象->变量：Value.Interface()  1. 要修改反射对象，其值必须可设置  #### 第五章 常用关键字* 前置知识：  * channel：c1:=chan int && c2:=c1 // 最后要么是c1要么是c2能收到消息  * 栈的自动增长，[Dive into stack and defer](http://hustcat.github.io/dive-into-stack-defer-panic-recover-in-go/)    * Go编译器在每个函数的开始插入一段检测栈是否够用的代码    * 如果空间不够则转到runtime.morestack_noctxt，分配一个新的足够大的栈空间    * 再将旧栈的内容拷贝到新栈中，然后再执行函数。* for k,v = range(m)：迭代前v已分配内存，每次迭代将元素值拷贝到v处* select如果含有default case则是非阻塞的* select如果没有default case则是阻塞的，有多个case发送则随机执行一个  * 随机生成一个轮询顺序pollOrder 并根据Channel地址生成锁定顺序lockOrder锁住所有Channel  * 根据pollOrder轮询每个case的channel，如果有可以处理的channel则立即处理，没有则：    * 根据lockOrder遍历case，将当前Goroutine加入到所有相关channel的收/发队列    * 同时创建runtime.sudog单链表，顺序同lockOrder    * 调用runtime.gopark休眠  * 当前Goroutine被唤醒(只会被一个channel唤醒)，根据lockOrder遍历找到此channel对应的case* defer的三种处理方法：  * 1.13前，在堆上分配runtime._defer结构体，defer处执行runtime.deferproc，退出函数执行runtime.deferreturn  * 1.13中，在栈上分配runtime._defer结构体(函数最多执行1次defer)，defer处执行runtime.deferprocStack，退出函数执行runtime.deferreturn  * 1.14中，开放编码(函数最多执行8次defer且defer不在循环结构中)    * 通过deferBits存储defer的相关信息    * 如果defer的执行可以在编译期确定，会在函数返回前直接插入相应的代码* defer func(...args) //args如果有表达式会在runtime.deferproc前计算好，参见defer-example1* panic和recover：  * 编译器将panic和recover转换成runtime.gopanic和runtime.gorecover  * 运行时执行runtime.gopanic，会从Goroutine的链表依次取出runtime._defer结构体并执行  * 遇到runtime.gorecover就会将_panic.recovered标记成true并返回panic的参数。在这次调用结束之后，runtime.gopanic还会调用runtime.recovery  * 没有遇到runtime.gorecover就会一直执行runtime._defer结构体，最后执行runtime.fatalpanic  * (如果执行runtime._defer结构体时又有panic，则加到runtime._panic链条，runtime.fatalpanic会统一打印)```// map的for-range执行时的伪代码key := nilval := nilmapiterinit(typeOfMap, map, &hit)for ; hit.key != nil; mapiternext(&hit) {    key = *hit.key    val = *hit.val    ...}// chan的for-range执行时的伪代码temp, ok := <-chanfor ; ok != false; temp, ok = <-chan {    val := temp    temp = nil    ...}// defer-example1：输出0func main() {	a := 0	defer println(a)	a = 1}// defer-example1：输出1func main() {	a := 0	defer func() {		println(a)	}()	a = 1}```#### 第六章 并发编程#### 第七章 内存管理  